\documentclass[11pt,a4paper,oneside]{article}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{amssymb}
%\usepackage{amsmath}
%\usepackage{mathabx}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage{bnf}
\newcommand{\lit}[1]{\mbox{`\texttt{#1}'}}
\newcommand{\ntm}[1]{<\mbox{#1}>}
\begin{document}


\begin{center}
\begin{Large}{\bfseries Домашние задания по курсу <<Математическая логика>>}\end{Large}\\
\vspace{1mm}
\begin{small} ИТМО, группы M3234..M3239\end{small}\\
\small Весна 2018 г.
\end{center}

%\renewcommand{\abstractname}{Общие замечания}
%\begin{abstract}
\subsection*{Общие замечания}
Для всех программ кодировка входных и выходных файлов должна быть UTF8. Задания 
подаются в систему Яндекс.контест, подробные описания --- по ссылке из README.md.
Для компиляции решения требуется использования мэйкфайлов, краткое описание
принципов построения мэйкфайлов находится в файле make.pdf из данного репозитория.
%\end{abstract}

\subsection*{Задача 0. Разбор выражения}
{\it Стоимость: 0 баллов, решение на Ocaml или Haskell: 0 баллов}\vspace{2mm}\\

Данная задача разобрана, решения её приведены (см. README.md), однако, мы крайне рекомендуем
написать своё её решение по двум причинам: (а) разбор высказываний можно будет переиспользовать 
в других задачах; (б) можно протестировать среду исполнения на Яндексе.

На вход программе (в файле \texttt{input.txt}) подаётся выражение в следующей грамматике:
\vspace{-1mm}
\begin{bnf}\begin{eqnarray*}
\ntm{файл} &::=& \ntm{выражение}\\
\ntm{выражение} &::=& \ntm{дизъюнкция} | \ntm{дизъюнкция} \lit{->} \ntm{выражение}\\
\ntm{дизъюнкция} &::=& \ntm{конъюнкция} | \ntm{дизъюнкция} \lit{|} \ntm{конъюнкция}\\
\ntm{конъюнкция} &::=& \ntm{отрицание} | \ntm{конъюнкция} \lit{\&} \ntm{отрицание}\\
\ntm{отрицание} &::=& (\lit{A} \dots \lit{Z}) \{\lit{A}\dots\lit{Z}|\lit{0}\dots\lit{9}\}^* | \lit{!} \ntm{отрицание} | \lit{(} \ntm{выражение} \lit{)}
\end{eqnarray*}\end{bnf}%

Пробелы, символы табуляции и возврата каретки (ASCII-код $13_{10}$) должны игнорироваться. 
Символ `\texttt{|}' имеет ASCII-код $124_{10}$.

Написать программу, разбирающую выражение и строящую его дерево разбора, и
выводящую полученное дерево в файл \texttt{output.txt} в следующей грамматике.
\vspace{-1mm}
\begin{bnf}\begin{eqnarray*}
\ntm{файл} &::=& \ntm{вершина}\\
\ntm{вершина} &::=& \lit{(}\ntm{знак}\lit{,}\ntm{вершина}\lit{,}\ntm{вершина}\lit{)}\\
                &|& \lit{(!}\ntm{вершина}\lit{)}\\
                &|& (\lit{A} \dots \lit{Z}) \{\lit{A}\dots\lit{Z}|\lit{0}\dots\lit{9}\}^*\\
\ntm{знак} &::=& \lit{\&} | \lit{|} | \lit{->}
\end{eqnarray*}\end{bnf}%

\subsubsection*{Пример входного файла:}
\begin{verbatim}
P->!QQ->!R10&S|!T&U&V
\end{verbatim}

\subsubsection*{Выходной файл для данного входного файла:}
\begin{verbatim}
(->,P,(->,(!QQ),(|,(&,(!R10),S),(&,(&,(!T),U),V))))
\end{verbatim}

\subsection*{Задача 1. Проверка вывода}
{\it Стоимость: 7 баллов, решение на Ocaml или Haskell: 9 баллов }\vspace{2mm}\\

Написать программу, проверяющую вывод $\gamma_1, \dots \gamma_n \vdash \alpha$ в исчислении 
высказываний на корректность. Входной файл соответствует следующей грамматике, нетерминал
\begin{bnf}$\ntm{выражение}$\end{bnf} определён в грамматике из задачи 0:

\begin{bnf}\begin{eqnarray*}
\ntm{файл} &::=& \ntm{заголовок} \lit{\textbackslash{}n} \{ \ntm{выражение} \lit{\textbackslash{}n}\}^*\\
\ntm{заголовок} &::=& \left[\ntm{выражение} \left\{ \lit{,}\ntm{выражение}\right\}^*\right] \lit{|-} \ntm{выражение}
\end{eqnarray*}\end{bnf}%

В первой строке входного файла (заголовок) перечислены предположения $\gamma_i$ (этот список может быть пустым) и 
доказываемое утверждение $\alpha$. В последующих строках указаны формулы, составляющие вывод формулы $\alpha$.
Пробелы, символы табуляции и возврата каретки (ASCII-код $13_{10}$) должны игнорироваться. 
Символ `\texttt{|}' имеет ASCII-код $124_{10}$.

Результатом работы программы должен быть файл с проаннотированным текстом доказательства,
в котором первая строка --- это заголовок из входного файла, каждая же последующая строка ---
соответствующая строка из вывода, расширенная в соответствии с грамматикой:
\begin{bnf}\begin{eqnarray*}
\ntm{строка} &::=& \lit{(} \ntm{номер} \lit{) } \ntm{выражение} \lit{ (} \ntm{аннотация} \lit{)}\\
\ntm{аннотация} &::=& \lit{Сх. акс. } \ntm{номер} \\
		&|& \lit{Предп. } \ntm{номер}\\
                &|& \lit{M.P. } \ntm{номер}\lit{, }\ntm{номер}\\
                &|& \lit{Не доказано}\\
\ntm{номер} &::=& \{\lit{0}\dots\lit{9}\}^+
\end{eqnarray*}\end{bnf}%

Выражение не должно содержать пробелов, номер от выражения и выражение от аннотации должны
отделяться одним пробелом. Выражения в доказательстве должны нумероваться подряд
натуральными числами с 1. Если выражение $\delta_n$ получено из 
$\delta_i$ и $\delta_j$, где $\delta_j \equiv \delta_i\rightarrow\delta_n$
путём применения правила Modus Ponens, то аннотация должна выглядеть как 
\lit{M.P. $i$, $j$}, обратный порядок номеров не допускается.

Уделите внимание производительности: ваша программа должна проверять доказательство в 
50000 выражений (общим объемом $1$Мб) на Intel Core i5-2520M ($2.5$ GHz) за несколько секунд.


\end{document}
